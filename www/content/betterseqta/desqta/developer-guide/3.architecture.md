---
title: Architecture Deep Dive
description: Understanding DesQTA's system architecture and design patterns
icon: lucide:network
---

## System Architecture

DesQTA follows a layered architecture with clear separation between frontend, backend, and external services. This section explains how all the pieces fit together.

## High-Level Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    User Interface                        │
│              (SvelteKit Frontend)                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ Components│  │  Routes  │  │  Stores  │             │
│  └──────────┘  └──────────┘  └──────────┘             │
│         │             │             │                   │
│         └─────────────┼─────────────┘                   │
│                       │                                 │
│              ┌────────▼────────┐                        │
│              │  Service Layer  │                        │
│              │  (Business Logic)│                        │
│              └────────┬─────────┘                        │
└───────────────────────┼─────────────────────────────────┘
                        │
                        │ invoke() / events
                        │
┌───────────────────────▼─────────────────────────────────┐
│              Tauri Command Bridge                       │
│         (Frontend ↔ Backend Communication)              │
└───────────────────────┬─────────────────────────────────┘
                        │
                        │
┌───────────────────────▼─────────────────────────────────┐
│            Rust Backend (Tauri)                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │   Auth   │  │  Network │  │  File    │             │
│  │  Module  │  │  Module  │  │  System  │             │
│  └──────────┘  └──────────┘  └──────────┘             │
│         │             │             │                   │
│         └─────────────┼─────────────┘                   │
│                       │                                 │
│              ┌────────▼────────┐                        │
│              │  Session Mgmt  │                        │
│              │  Settings Store │                        │
│              └────────┬─────────┘                        │
└───────────────────────┼─────────────────────────────────┘
                        │
                        │ HTTP Requests
                        │
┌───────────────────────▼─────────────────────────────────┐
│              External Services                           │
│  ┌──────────────┐  ┌──────────────┐                  │
│  │ SEQTA Learn  │  │ BetterSEQTA   │                  │
│  │     API      │  │ Cloud API     │                  │
│  └──────────────┘  └──────────────┘                  │
└─────────────────────────────────────────────────────────┘
```

## Frontend Architecture

### SvelteKit Structure

DesQTA uses SvelteKit's file-based routing system:

```
src/routes/
├── +layout.svelte          # Root layout (header, sidebar)
├── +layout.ts              # Layout data loader
├── +page.svelte            # Dashboard/homepage
├── +error.svelte           # Error page
├── assessments/
│   ├── +page.svelte        # Assessments list
│   └── [id]/
│       └── [metaclass]/
│           ├── +page.svelte # Assessment detail
│           └── +page.ts     # Data loader
├── timetable/
│   └── +page.svelte        # Timetable page
└── settings/
    └── +page.svelte        # Settings page
```

### Component Architecture

Components are organized by purpose:

```
src/lib/components/
├── ui/                     # Base UI components (buttons, cards, etc.)
├── layout/                 # Layout components (header, sidebar)
├── content/                # Content components (assessments, timetable)
└── [feature]/              # Feature-specific components
```

### Service Layer Pattern

Services encapsulate business logic:

```typescript
// src/lib/services/authService.ts
export const authService = {
  async checkSession(): Promise<boolean> {
    return await invoke('check_session_exists');
  },
  
  async loadUserInfo(): Promise<UserInfo | undefined> {
    // Implementation
  }
};
```

**Service Responsibilities:**
- API communication
- Data transformation
- Caching logic
- Error handling

### State Management

DesQTA uses multiple state management approaches:

**1. Svelte 5 Runes (Component State)**
```typescript
let count = $state(0);
let doubled = $derived(count * 2);
$effect(() => {
  console.log('Count changed:', count);
});
```

**2. Svelte Stores (Global State)**
```typescript
// src/lib/stores/theme.ts
export const theme = writable<'light' | 'dark' | 'system'>('system');
export const accentColor = writable('#3b82f6');
```

**3. Service State (Business Logic)**
```typescript
// Services maintain their own state
class AuthService {
  private user: UserInfo | null = null;
  // ...
}
```

## Backend Architecture

### Tauri Command System

Commands are Rust functions exposed to the frontend:

```rust
// src-tauri/src/lib.rs
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

// Register in main()
.invoke_handler(tauri::generate_handler![greet])
```

**Frontend Usage:**
```typescript
import { invoke } from '@tauri-apps/api/core';
const greeting = await invoke('greet', { name: 'World' });
```

### Module Organization

Backend code is organized into modules:

```
src-tauri/src/
├── lib.rs                  # Main entry, command registration
├── main.rs                 # Application entrypoint
├── auth/
│   └── login.rs           # Authentication logic
├── utils/
│   ├── netgrab.rs         # HTTP client
│   ├── settings.rs        # Settings management
│   ├── session.rs         # Session handling
│   └── analytics.rs       # Analytics
└── global_search.rs       # Global search functionality
```

### Session Management

Sessions are stored locally and managed by Rust:

```rust
// src-tauri/src/utils/session.rs
pub struct Session {
    pub base_url: String,
    pub jsessionid: String,
    pub additional_cookies: Vec<Cookie>,
}

impl Session {
    pub fn load() -> Self { /* ... */ }
    pub fn save(&self) -> io::Result<()> { /* ... */ }
    pub fn exists() -> bool { /* ... */ }
}
```

## Data Flow

### Request Flow

```
User Action
    │
    ▼
Component Event Handler
    │
    ▼
Service Function
    │
    ▼
Tauri invoke() Call
    │
    ▼
Rust Command Handler
    │
    ▼
HTTP Request (if needed)
    │
    ▼
Response Processing
    │
    ▼
State Update
    │
    ▼
UI Re-render
```

### Example: Loading Assessments

```typescript
// 1. Component triggers load
onMount(async () => {
  await loadAssessments();
});

// 2. Service function called
async function loadAssessments() {
  const data = await useDataLoader({
    cacheKey: 'assessments',
    fetcher: async () => {
      // 3. Tauri command invoked
      return await invoke('get_processed_assessments');
    }
  });
}

// 4. Rust command executes
#[tauri::command]
pub async fn get_processed_assessments() -> Result<AssessmentsData, String> {
    // 5. Fetch from SEQTA API
    let response = fetch_from_seqta().await?;
    // 6. Process and return
    Ok(process_assessments(response))
}
```

## Caching Strategy

DesQTA implements a sophisticated multi-level caching system. See the [Caching Strategy](/betterseqta/desqta/developer-guide/architecture/caching) guide for complete details.

**Cache Layers:**
- **Memory Cache**: Fast, in-memory LRU cache with TTL
- **IndexedDB Cache**: Persistent browser storage
- **File System Cache**: Backend persistent storage
- **Database Cache**: SQLite for structured data

**Cache TTL Presets:**
- `SHORT`: 5 minutes (API responses)
- `MEDIUM`: 15 minutes (user data)
- `LONG`: 60 minutes (static content)
- `VERY_LONG`: 24 hours (configuration)

## Error Handling

### Frontend Error Handling

```typescript
// Service-level error handling
try {
  const data = await fetchData();
} catch (error) {
  logger.error('context', 'function', `Error: ${error}`);
  errorService.handleError(error);
  // Show user-friendly message
}

// Component-level error handling
{#if error}
  <ErrorMessage {error} />
{/if}
```

### Backend Error Handling

```rust
#[tauri::command]
pub async fn risky_operation() -> Result<String, String> {
    match do_something() {
        Ok(result) => Ok(result),
        Err(e) => Err(format!("Operation failed: {}", e))
    }
}
```

## Security Architecture

### Authentication Flow

1. **User enters SEQTA URL**
2. **Login window opens** (browser or QR code)
3. **Session created** after successful login
4. **Session stored** locally (encrypted)
5. **Session validated** on each API call

### Session Security

- Sessions stored locally (not in browser)
- JSESSIONID cookies managed securely
- Session validation on app launch
- Automatic logout on session expiry

### Data Security

- HTTPS only for API calls
- No sensitive data in logs (dev mode)
- Secure file storage
- Encrypted settings (future)

## Performance Optimization

### Frontend Optimizations

1. **Code Splitting**: Route-based automatic splitting
2. **Lazy Loading**: Components loaded on demand
3. **Caching**: Aggressive caching strategy
4. **Virtual Scrolling**: For long lists
5. **Debouncing**: Input handlers debounced

### Backend Optimizations

1. **Connection Pooling**: Reuse HTTP connections
2. **Request Deduplication**: Prevent duplicate requests
3. **Async Operations**: Non-blocking I/O
4. **Memory Management**: Efficient Rust memory usage

## Testing Architecture

### Frontend Testing

- **Unit Tests**: Component testing with Vitest
- **Integration Tests**: Service testing
- **E2E Tests**: Playwright (planned)

### Backend Testing

- **Unit Tests**: Rust unit tests
- **Integration Tests**: Tauri command testing
- **API Mocking**: Mock SEQTA API responses

## Extension Points

### Plugin System (Planned)

Future plugin architecture:

```typescript
// Plugin interface
interface DesQTAPlugin {
  name: string;
  version: string;
  init(app: DesQTAApp): void;
  routes?: Route[];
  components?: Component[];
}
```

### Theme System

Extensible theme system:

```typescript
// Custom theme
interface ThemeManifest {
  name: string;
  version: string;
  settings: ThemeSettings;
  customProperties: Record<string, string>;
}
```

## Next Steps

- [Frontend Development](/betterseqta/desqta/developer-guide/frontend) - Deep dive into SvelteKit
- [Backend Development](/betterseqta/desqta/developer-guide/backend) - Rust and Tauri details
- [Adding Features](/betterseqta/desqta/developer-guide/adding-features) - How to extend DesQTA

