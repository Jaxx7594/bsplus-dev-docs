---
title: Adding Features
description: Step-by-step guide to adding new features to DesQTA
icon: lucide:plus-circle
---

## Feature Development Workflow

This guide walks you through adding a new feature to DesQTA, from planning to implementation.

## Planning Your Feature

### 1. Define Requirements

Before coding, clearly define:
- **What** the feature does
- **Why** it's needed
- **How** users will interact with it
- **Where** it fits in the app

### 2. Check Existing Code

Search for similar functionality:
- Check if feature already exists
- Look for related components/services
- Find reusable patterns

### 3. Design the Implementation

Plan your approach:
- Frontend components needed
- Backend commands required
- Data structures
- API endpoints

## Example: Adding a Notes Feature

Let's walk through adding a simple notes feature as an example.

## Step 1: Backend Implementation

### Create Rust Module

```rust
// src-tauri/src/utils/notes.rs
use serde::{Deserialize, Serialize};
use std::fs;
use std::io;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Note {
    pub id: String,
    pub title: String,
    pub content: String,
    pub created_at: String,
    pub updated_at: String,
}

fn notes_file() -> std::path::PathBuf {
    let mut dir = dirs_next::data_dir().expect("Unable to determine data dir");
    dir.push("DesQTA");
    dir.push("notes.json");
    dir
}

#[tauri::command]
pub fn get_notes() -> Result<Vec<Note>, String> {
    let path = notes_file();
    if !path.exists() {
        return Ok(vec![]);
    }
    
    let contents = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read notes: {}", e))?;
    
    let notes: Vec<Note> = serde_json::from_str(&contents)
        .map_err(|e| format!("Failed to parse notes: {}", e))?;
    
    Ok(notes)
}

#[tauri::command]
pub fn save_note(note: Note) -> Result<(), String> {
    let mut notes = get_notes().unwrap_or_default();
    
    // Update existing or add new
    if let Some(existing) = notes.iter_mut().find(|n| n.id == note.id) {
        *existing = note;
    } else {
        notes.push(note);
    }
    
    let json = serde_json::to_string(&notes)
        .map_err(|e| format!("Failed to serialize notes: {}", e))?;
    
    fs::write(notes_file(), json)
        .map_err(|e| format!("Failed to write notes: {}", e))?;
    
    Ok(())
}

#[tauri::command]
pub fn delete_note(id: String) -> Result<(), String> {
    let mut notes = get_notes().unwrap_or_default();
    notes.retain(|n| n.id != id);
    
    let json = serde_json::to_string(&notes)
        .map_err(|e| format!("Failed to serialize notes: {}", e))?;
    
    fs::write(notes_file(), json)
        .map_err(|e| format!("Failed to write notes: {}", e))?;
    
    Ok(())
}
```

### Register Commands

```rust
// src-tauri/src/lib.rs
mod utils;

use utils::notes;

// In main() function
.invoke_handler(tauri::generate_handler![
    // ... existing commands
    notes::get_notes,
    notes::save_note,
    notes::delete_note,
])
```

## Step 2: Frontend Service

### Create Service

```typescript
// src/lib/services/notesService.ts
import { invoke } from '@tauri-apps/api/core';

export interface Note {
  id: string;
  title: string;
  content: string;
  created_at: string;
  updated_at: string;
}

export const notesService = {
  async getNotes(): Promise<Note[]> {
    return await invoke<Note[]>('get_notes');
  },

  async saveNote(note: Note): Promise<void> {
    await invoke('save_note', { note });
  },

  async deleteNote(id: string): Promise<void> {
    await invoke('delete_note', { id });
  },

  async createNote(title: string, content: string): Promise<Note> {
    const note: Note = {
      id: crypto.randomUUID(),
      title,
      content,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    await this.saveNote(note);
    return note;
  },
};
```

## Step 3: Create Components

### Notes List Component

```svelte
<!-- src/lib/components/NotesList.svelte -->
<script lang="ts">
  import { notesService, type Note } from '$lib/services/notesService';
  import { onMount } from 'svelte';

  let notes = $state<Note[]>([]);
  let loading = $state(true);

  onMount(async () => {
    await loadNotes();
  });

  async function loadNotes() {
    loading = true;
    notes = await notesService.getNotes();
    loading = false;
  }

  async function deleteNote(id: string) {
    await notesService.deleteNote(id);
    await loadNotes();
  }
</script>

<div class="notes-list">
  {#if loading}
    <p>Loading notes...</p>
  {:else if notes.length === 0}
    <p>No notes yet. Create your first note!</p>
  {:else}
    {#each notes as note}
      <div class="note-item">
        <h3>{note.title}</h3>
        <p>{note.content}</p>
        <button onclick={() => deleteNote(note.id)}>Delete</button>
      </div>
    {/each}
  {/if}
</div>
```

### Note Editor Component

```svelte
<!-- src/lib/components/NoteEditor.svelte -->
<script lang="ts">
  import { notesService, type Note } from '$lib/services/notesService';

  interface Props {
    note?: Note;
    onSave?: () => void;
  }

  let { note, onSave }: Props = $props();

  let title = $state(note?.title || '');
  let content = $state(note?.content || '');

  async function handleSave() {
    const noteToSave: Note = note || {
      id: crypto.randomUUID(),
      title: '',
      content: '',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    noteToSave.title = title;
    noteToSave.content = content;
    noteToSave.updated_at = new Date().toISOString();

    await notesService.saveNote(noteToSave);
    onSave?.();
  }
</script>

<div class="note-editor">
  <input
    type="text"
    bind:value={title}
    placeholder="Note title"
    class="title-input"
  />
  <textarea
    bind:value={content}
    placeholder="Note content"
    class="content-input"
  />
  <button onclick={handleSave}>Save</button>
</div>
```

## Step 4: Create Route

### Notes Page

```svelte
<!-- src/routes/notes/+page.svelte -->
<script lang="ts">
  import NotesList from '$lib/components/NotesList.svelte';
  import NoteEditor from '$lib/components/NoteEditor.svelte';

  let showEditor = $state(false);
</script>

<div class="notes-page">
  <header>
    <h1>Notes</h1>
    <button onclick={() => (showEditor = !showEditor)}>
      {showEditor ? 'Cancel' : 'New Note'}
    </button>
  </header>

  {#if showEditor}
    <NoteEditor
      onSave={() => {
        showEditor = false;
        // Refresh list
      }}
    />
  {/if}

  <NotesList />
</div>
```

### Add to Navigation

Update the sidebar menu in `+layout.svelte`:

```svelte
const DEFAULT_MENU = [
  // ... existing items
  { labelKey: 'navigation.notes', icon: DocumentText, path: '/notes' },
];
```

## Step 5: Add Types

### TypeScript Types

```typescript
// src/lib/types.ts (add to existing file)
export interface Note {
  id: string;
  title: string;
  content: string;
  created_at: string;
  updated_at: string;
}
```

## Step 6: Styling

### Add Styles

```svelte
<!-- In your component -->
<style>
  .notes-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .note-item {
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
  }

  .note-editor {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
</style>
```

## Step 7: Testing

### Test Backend

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_save_and_get_note() {
        let note = Note {
            id: "test-id".to_string(),
            title: "Test".to_string(),
            content: "Content".to_string(),
            created_at: "2024-01-01".to_string(),
            updated_at: "2024-01-01".to_string(),
        };
        
        save_note(note.clone()).unwrap();
        let notes = get_notes().unwrap();
        
        assert!(notes.contains(&note));
    }
}
```

### Test Frontend

```typescript
// Component test
import { render, screen } from '@testing-library/svelte';
import NotesList from './NotesList.svelte';

test('renders notes list', async () => {
  render(NotesList);
  // Add assertions
});
```

## Step 8: Documentation

### Update Documentation

1. Add feature to user guide
2. Document API in developer guide
3. Add code comments
4. Update changelog

## Best Practices

### Code Organization
- Keep related code together
- Use consistent naming
- Follow existing patterns
- Separate concerns

### Error Handling
- Handle all errors gracefully
- Provide user-friendly messages
- Log errors appropriately
- Test error cases

### Performance
- Cache when appropriate
- Lazy load heavy components
- Optimize re-renders
- Profile before optimizing

### Testing
- Write tests for new code
- Test edge cases
- Test error handling
- Keep tests maintainable

## Common Patterns

### CRUD Operations

Most features follow CRUD pattern:
- **Create**: Add new item
- **Read**: Fetch items
- **Update**: Modify existing item
- **Delete**: Remove item

### Data Flow

Standard data flow:
1. User action triggers event
2. Component calls service
3. Service calls Tauri command
4. Backend processes request
5. Response updates state
6. UI re-renders

### State Management

Choose appropriate state:
- **Component state**: Local to component
- **Store**: Shared across components
- **Service state**: Business logic state

## Next Steps

After implementing your feature:

1. **Test thoroughly**: Manual and automated tests
2. **Get feedback**: Share with team/users
3. **Refine**: Iterate based on feedback
4. **Document**: Update documentation
5. **Submit PR**: Follow contribution guidelines

## Resources

- [Frontend Development](/betterseqta/desqta/developer-guide/frontend) - SvelteKit patterns
- [Backend Development](/betterseqta/desqta/developer-guide/backend) - Rust/Tauri patterns
- [Architecture](/betterseqta/desqta/developer-guide/architecture) - System design

